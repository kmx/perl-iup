/* BEWARE: this is a generated file, DO NOT EDIT THIS FILE MANUALLY!!! */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"

#include <iup.h>
#include <cd.h>

/* ### BEWARE ### Ugly workaround needed for old cygwin with perl-5.10.0 */
#if !defined(MUTABLE_PTR)
#define MUTABLE_PTR(p) ((void *) (p))
#endif
/* end-of-workaround */

SV* ihandle2SV_nocreate(Ihandle* ih) {  
  SV *ptrSV, **ref;
  HV* globreg;
  char* hkey; /*string with numeric representation of canvas pointer*/

  ptrSV = newSViv(PTR2IV(ih)); 
  hkey = SvPV_nolen(ptrSV); /*xxxCHECKLATER find more effective way of converting ih > hkey*/
  
  globreg = get_hv("IUP::Internal::LibraryIup::ih_register", 0);
  /*### check if canvas pointer is present in global hash 'ih_register' */
  ref = hv_fetch(globreg, hkey, strlen(hkey), 0);
  if (ref != NULL)
    if (SvOK(*ref)) return *ref; /* return $IUP::Internal::LibraryIup::ih_register{$hkey} */
  
  /*### if not found in ih_register return undef */
  return &PL_sv_undef;
}

SV* ihandle2SV(Ihandle* ih, SV* element, char* action_related_key) { /*xxxCHECKLATER should be OK but was not tested yet*/
  SV *ptrSV, *obj, **ref;
  HV *globreg, *newhash, *element_hash, *element_cbrelated_hash;
  char* hkey; /*string with numeric representation of canvas pointer*/

  ptrSV = newSViv(PTR2IV(ih));
  hkey = SvPV_nolen(ptrSV); /*xxxCHECKLATER find more effective way of converting ih > hkey*/
  globreg = get_hv("IUP::Internal::LibraryIup::ih_register", 0);

  /*### check if canvas pointer is present in global hash 'ih_register' */
  ref = hv_fetch(globreg, hkey, strlen(hkey), 0);
  if (ref != NULL)
    if (SvOK(*ref)) return *ref; /* return $IUP::Internal::LibraryIup::ch_register{$hkey} */
  
  /*warn("***DEBUG*** need to create IUP::Internal::Element %s\n",hkey);*/
  
  /*### create new IUP::Internal::Element object based on given ihandle*/
  /* see http://stackoverflow.com/questions/1497836/how-do-i-write-a-perl-constructor-in-xs */
  newhash = (HV *)sv_2mortal((SV *)newHV());
  obj = sv_bless( newRV((SV*)newhash), gv_stashpv("IUP::Internal::Element", 1) );
  hv_store(newhash, "!int!ihandle", 12, ptrSV, 0);
  if (!SvOK(obj)) { warn("Warning: This shouldn't happen ih1\n"); return &PL_sv_undef; }

  /*### $IUP::Internal::LibraryIup::ch_register{<hkey>} = newSVsv(obj) */
  /*### weaken($IUP::Internal::LibraryIup::ch_register{<hkey>}) */
  hv_store(globreg, hkey, strlen(hkey), sv_rvweaken(newSVsv(obj)), 0); /* weaken */  

  /*### $element->{'!int!cb!<action>!related'}->{<hkey>} = newSVsv(obj) */
  element_hash = (HV*)MUTABLE_PTR(SvRV(element));
  ref = hv_fetch(element_hash, action_related_key, strlen(action_related_key), 0);
  if (ref == NULL) { warn("Warning: This shouldn't happen ih2\n"); return sv_2mortal(obj); }
  if (!SvOK(*ref)) { warn("Warning: This shouldn't happen ih3\n"); return sv_2mortal(obj); }
  element_cbrelated_hash = (HV*)MUTABLE_PTR(SvRV(*ref));
  hv_store(element_cbrelated_hash, hkey, strlen(hkey), newSVsv(obj), 0); /* nonweaken */
  
  return sv_2mortal(obj);
}

SV* canvas2SV(cdCanvas* canvas, SV* element, char* action_related_key) {
  SV *ptrSV, *obj, **ref;
  HV *globreg, *newhash, *element_hash, *element_cbrelated_hash;
  char* hkey; /*string with numeric representation of canvas pointer*/
  
  ptrSV = newSViv(PTR2IV(canvas));
  hkey = SvPV_nolen(ptrSV); /*xxxCHECKLATER find more effective way of converting ih > hkey*/
  globreg = get_hv("IUP::Internal::LibraryIup::ch_register", 0);

  /*### check if canvas pointer is present in global hash 'ch_register' */  
  ref = hv_fetch(globreg, hkey, strlen(hkey), 0);
  if (ref != NULL) 
    if (SvOK(*ref)) return *ref; /* return $IUP::Internal::LibraryIup::ch_register{<hkey>} */
  
  /*warn("***DEBUG*** need to create IUP::Internal::Canvas %s\n",hkey);*/
  
  /*### create new IUP::Internal::Canvas object based on given canvas handle*/
  /* see http://stackoverflow.com/questions/1497836/how-do-i-write-a-perl-constructor-in-xs */
  newhash = (HV *)sv_2mortal((SV *)newHV());
  obj = sv_bless( newRV((SV*)newhash), gv_stashpv("IUP::Internal::Canvas", 1) );
  hv_store(newhash, "!int!cnvhandle", 14, ptrSV, 0);
  if (!SvOK(obj)) { warn("Warning: This shouldn't happen cv1\n"); return &PL_sv_undef; }

  /*### $IUP::Internal::LibraryIup::ch_register{<hkey>} = newSVsv(obj) */
  /*### weaken($IUP::Internal::LibraryIup::ch_register{<hkey>}) */
  hv_store(globreg, hkey, strlen(hkey), sv_rvweaken(newSVsv(obj)), 0); /* weaken */  

  /*### $element->{'!int!cb!<action>!related'}->{<hkey>} = newSVsv(obj) */
  element_hash = (HV*)MUTABLE_PTR(SvRV(element));
  ref = hv_fetch(element_hash, action_related_key, strlen(action_related_key), 0);
  if (ref == NULL) { warn("Warning: This shouldn't happen cv2\n"); return sv_2mortal(obj); }
  if (!SvOK(*ref)) { warn("Warning: This shouldn't happen cv3\n"); return sv_2mortal(obj); }
  element_cbrelated_hash = (HV*)MUTABLE_PTR(SvRV(*ref));
  hv_store(element_cbrelated_hash, hkey, strlen(hkey), newSVsv(obj), 0); /* nonweaken */

  return sv_2mortal(obj);
}

int call_cb_func(SV* element, char *actionkey) {
  HV *hash;
  SV **ref;

  /* call_pv(element->{actionkey},G_ARRAY) */
  hash = (HV*)MUTABLE_PTR(SvRV(element));
  ref = hv_fetch(hash, actionkey, strlen(actionkey), 0);
  if (ref != NULL)
    if (SvOK(*ref)) return call_sv(*ref,G_ARRAY); /*xxxCHECKLATER better would be to test blessed(*ref)*/
  warn("Warning: callback failed, $element->{'%s'} undefined\n");
  return 0;
}
[% FOREACH i IN xsitems %]
[% i.c_retval %]
[% i.xs_internal_cb %] [% i.xs_internal_cb_params %]
{
	dSP;
	int count;
	[% i.c_retval %] rv;
	[%IF i.xs_declare_sv_rv%][% i.xs_declare_sv_rv %];[%END%]
	SV* element;
	
	rv = [% i.xs_internal_default_rv %];
	element = ihandle2SV_nocreate(ih);
	if(!SvOK(element)) {
	  warn("Warning: callback [%xs_init_cb_action%] - cannot convert ihandle!\n");
	  return rv;
	}
[% IF i.xs_spec_NODEREMOVED_CB -%]
	SV * SV_userdata, **SV_ref;
	char * hkey_userdata;
	HV *element_hash;
[% ELSE -%]
  [% FOR j IN i.xs_internal_cb_locvar -%]
	[% j %]
  [% END -%]
[% END -%]

	ENTER;
	SAVETMPS;

	/* push params for [% i.xs_internal_cb_pfunc %]() */
	PUSHMARK(SP);
	XPUSHs(element);
[% IF i.xs_spec_NODEREMOVED_CB -%]
       /* converting userdata to  $self->{'!int!treedata'}->{$userdata_pointer} */
	SV_userdata = newSViv(PTR2IV(userdata));
	hkey_userdata = SvPV_nolen(SV_userdata); /*xxxCHECKLATER find more effective way*/
	element_hash = (HV*)MUTABLE_PTR(SvRV(element));
	SV_ref = hv_fetch(element_hash, "!int!treedata", 13, 0);
	if ((SV_ref == NULL) || !SvOK(*SV_ref)) {
	  warn("Warning: This shouldn't happen NODEREMOVED_CB/1\n"); 
	  XPUSHs(&PL_sv_undef);
	}
	else {
	  element_hash = (HV*)MUTABLE_PTR(SvRV(*SV_ref));
	  SV_ref = hv_fetch(element_hash, hkey_userdata, strlen(hkey_userdata), 0);
	  if ((SV_ref == NULL) || !SvOK(*SV_ref)) {
	    warn("Warning: This shouldn't happen NODEREMOVED_CB/2\n"); 
	    XPUSHs(&PL_sv_undef);
	  }
          else XPUSHs(*SV_ref);
        }        
        /* converting userdata - done */
[% ELSE -%]
  [% FOREACH j IN i.xs_internal_cb_push -%]
	[% j %]
  [% END -%]
[% END -%]
	PUTBACK;

	count = call_cb_func(element,"[% i.xs_internal_action_key %]");

	SPAGAIN;

	[% i.xs_internal_cb_rvcheck %]
	else {
[% FOR j IN i.xs_internal_cb_extrapop -%]
	  [% j %]
[% END -%]
[% IF i.xs_declare_sv_rv -%]
	  SV_rv = POPs;
	  if (SvOK(SV_rv)) rv = SvIV(SV_rv);
[% ELSE -%]
	  rv = [% i.xs_internal_cb_pop %];
[% END -%]
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 
[% END %]

MODULE = IUP::Internal::Callback	PACKAGE = IUP::Internal::Callback

BOOT:
/* empty boot */

void
_clear_cb(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, NULL);

[% FOREACH i IN xsitems %]
void
[% i.xs_init_cb %](ih)
		Ihandle* ih;
	CODE:
		IupSetCallback(ih, "[% i.xs_init_cb_action %]", (Icallback)[% i.xs_internal_cb %]);
[% END %]
